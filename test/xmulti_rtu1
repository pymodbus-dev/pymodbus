import logging

from pymodbus.framer.rtu_framer import ModbusRtuFramer
from pymodbus.utilities import checkCRC
import struct

log = logging.getLogger(__name__)


class PatchedModbusRtuFramer(ModbusRtuFramer):
    def isFrameIntendedForUs(self, units: list[int]):
        try:
            unit = self._buffer[0]
            return unit in units
        except IndexError as e:
            return True

    def advanceToNextOccurrenceOfUnit(self, units: list[int]):
        j = None
        for i, b in enumerate(self._buffer):
            if b in units and i > 0:
                j = i
                break

        if j:
            self._buffer = self._buffer[j:]
        else:
            self._buffer = b""

        self._header = {"uid": 0x00, "len": 0, "crc": b"\x00\x00"}
        return len(self._buffer)

    def checkFrame(self):
        try:
            self.populateHeader()
            frame_size = self._header["len"]

            if len(self._buffer) > frame_size:
                # This means there are bytes *after* a valid frame intended to us.
                # If there are bytes after that means we've probably de-sychronized
                # and the master has considered us as having timed out and moved on.
                # That or there is somehow a random sequence of bytes which looks like
                # a real command to us and magically a crc.
                # In either case, we must not respond.
                return False

            data = self._buffer[: frame_size - 2]
            crc = self._header["crc"]
            crc_val = (int(crc[0]) << 8) + int(crc[1])
            return checkCRC(data, crc_val)
        except (IndexError, KeyError, struct.error):
            return False

    def processIncomingPacket(self, data, callback, unit, **kwargs):
        if not isinstance(unit, (list, tuple)):
            unit = [unit]
        self.addToFrame(data)
        single = kwargs.get("single", False)
        while True:
            if not self.isFrameIntendedForUs(unit):
                if self.advanceToNextOccurrenceOfUnit(unit) == 0:
                    log.info(f"❌ Frame - [{data}] not intended for us, ignoring!!")
                    break
            elif self.isFrameReady():
                if self.checkFrame():
                    if self._validate_unit_id(unit, single):
                        self._process(callback)
                        log.info(f"✅ Frame - [{data}] responded to!!")
                    else:
                        header_txt = self._header["uid"]
                        log.info(f"Not a valid unit id - {header_txt}, ignoring!!")
                        self.resetFrame()
                        break
                else:
                    log.info("Frame check failed, ignoring!!")
                    if self.advanceToNextOccurrenceOfUnit(unit) == 0:
                        break
            else:
                log.info(f"Frame - [{data}] not ready")
                break
